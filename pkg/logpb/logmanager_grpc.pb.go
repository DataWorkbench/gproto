// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.3
// source: proto/logmanager.proto

package logpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LogManagerClient is the client API for LogManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogManagerClient interface {
	ListJMHistoryLogFiles(ctx context.Context, in *ListHistLogsRequest, opts ...grpc.CallOption) (*ListJMHistLogsReply, error)
	ListTMHistoryLogFiles(ctx context.Context, in *ListHistLogsRequest, opts ...grpc.CallOption) (*ListTMHistLogsReply, error)
	DownloadJobMgrLogFile(ctx context.Context, in *DownloadJobMgrRequest, opts ...grpc.CallOption) (LogManager_DownloadJobMgrLogFileClient, error)
	DownloadTaskMgrLogFile(ctx context.Context, in *DownloadTaskMgrRequest, opts ...grpc.CallOption) (LogManager_DownloadTaskMgrLogFileClient, error)
	UploadLogFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileReply, error)
	GetUploadingTaskStat(ctx context.Context, in *TaskStatRequest, opts ...grpc.CallOption) (*TaskStatReply, error)
}

type logManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewLogManagerClient(cc grpc.ClientConnInterface) LogManagerClient {
	return &logManagerClient{cc}
}

func (c *logManagerClient) ListJMHistoryLogFiles(ctx context.Context, in *ListHistLogsRequest, opts ...grpc.CallOption) (*ListJMHistLogsReply, error) {
	out := new(ListJMHistLogsReply)
	err := c.cc.Invoke(ctx, "/LogManager/ListJMHistoryLogFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logManagerClient) ListTMHistoryLogFiles(ctx context.Context, in *ListHistLogsRequest, opts ...grpc.CallOption) (*ListTMHistLogsReply, error) {
	out := new(ListTMHistLogsReply)
	err := c.cc.Invoke(ctx, "/LogManager/ListTMHistoryLogFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logManagerClient) DownloadJobMgrLogFile(ctx context.Context, in *DownloadJobMgrRequest, opts ...grpc.CallOption) (LogManager_DownloadJobMgrLogFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &LogManager_ServiceDesc.Streams[0], "/LogManager/DownloadJobMgrLogFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &logManagerDownloadJobMgrLogFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogManager_DownloadJobMgrLogFileClient interface {
	Recv() (*FileContent, error)
	grpc.ClientStream
}

type logManagerDownloadJobMgrLogFileClient struct {
	grpc.ClientStream
}

func (x *logManagerDownloadJobMgrLogFileClient) Recv() (*FileContent, error) {
	m := new(FileContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logManagerClient) DownloadTaskMgrLogFile(ctx context.Context, in *DownloadTaskMgrRequest, opts ...grpc.CallOption) (LogManager_DownloadTaskMgrLogFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &LogManager_ServiceDesc.Streams[1], "/LogManager/DownloadTaskMgrLogFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &logManagerDownloadTaskMgrLogFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LogManager_DownloadTaskMgrLogFileClient interface {
	Recv() (*FileContent, error)
	grpc.ClientStream
}

type logManagerDownloadTaskMgrLogFileClient struct {
	grpc.ClientStream
}

func (x *logManagerDownloadTaskMgrLogFileClient) Recv() (*FileContent, error) {
	m := new(FileContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logManagerClient) UploadLogFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileReply, error) {
	out := new(UploadFileReply)
	err := c.cc.Invoke(ctx, "/LogManager/UploadLogFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logManagerClient) GetUploadingTaskStat(ctx context.Context, in *TaskStatRequest, opts ...grpc.CallOption) (*TaskStatReply, error) {
	out := new(TaskStatReply)
	err := c.cc.Invoke(ctx, "/LogManager/GetUploadingTaskStat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogManagerServer is the server API for LogManager service.
// All implementations must embed UnimplementedLogManagerServer
// for forward compatibility
type LogManagerServer interface {
	ListJMHistoryLogFiles(context.Context, *ListHistLogsRequest) (*ListJMHistLogsReply, error)
	ListTMHistoryLogFiles(context.Context, *ListHistLogsRequest) (*ListTMHistLogsReply, error)
	DownloadJobMgrLogFile(*DownloadJobMgrRequest, LogManager_DownloadJobMgrLogFileServer) error
	DownloadTaskMgrLogFile(*DownloadTaskMgrRequest, LogManager_DownloadTaskMgrLogFileServer) error
	UploadLogFile(context.Context, *UploadFileRequest) (*UploadFileReply, error)
	GetUploadingTaskStat(context.Context, *TaskStatRequest) (*TaskStatReply, error)
	mustEmbedUnimplementedLogManagerServer()
}

// UnimplementedLogManagerServer must be embedded to have forward compatible implementations.
type UnimplementedLogManagerServer struct {
}

func (UnimplementedLogManagerServer) ListJMHistoryLogFiles(context.Context, *ListHistLogsRequest) (*ListJMHistLogsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJMHistoryLogFiles not implemented")
}
func (UnimplementedLogManagerServer) ListTMHistoryLogFiles(context.Context, *ListHistLogsRequest) (*ListTMHistLogsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTMHistoryLogFiles not implemented")
}
func (UnimplementedLogManagerServer) DownloadJobMgrLogFile(*DownloadJobMgrRequest, LogManager_DownloadJobMgrLogFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadJobMgrLogFile not implemented")
}
func (UnimplementedLogManagerServer) DownloadTaskMgrLogFile(*DownloadTaskMgrRequest, LogManager_DownloadTaskMgrLogFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadTaskMgrLogFile not implemented")
}
func (UnimplementedLogManagerServer) UploadLogFile(context.Context, *UploadFileRequest) (*UploadFileReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadLogFile not implemented")
}
func (UnimplementedLogManagerServer) GetUploadingTaskStat(context.Context, *TaskStatRequest) (*TaskStatReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUploadingTaskStat not implemented")
}
func (UnimplementedLogManagerServer) mustEmbedUnimplementedLogManagerServer() {}

// UnsafeLogManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogManagerServer will
// result in compilation errors.
type UnsafeLogManagerServer interface {
	mustEmbedUnimplementedLogManagerServer()
}

func RegisterLogManagerServer(s grpc.ServiceRegistrar, srv LogManagerServer) {
	s.RegisterService(&LogManager_ServiceDesc, srv)
}

func _LogManager_ListJMHistoryLogFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHistLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogManagerServer).ListJMHistoryLogFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LogManager/ListJMHistoryLogFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogManagerServer).ListJMHistoryLogFiles(ctx, req.(*ListHistLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogManager_ListTMHistoryLogFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHistLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogManagerServer).ListTMHistoryLogFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LogManager/ListTMHistoryLogFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogManagerServer).ListTMHistoryLogFiles(ctx, req.(*ListHistLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogManager_DownloadJobMgrLogFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadJobMgrRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogManagerServer).DownloadJobMgrLogFile(m, &logManagerDownloadJobMgrLogFileServer{stream})
}

type LogManager_DownloadJobMgrLogFileServer interface {
	Send(*FileContent) error
	grpc.ServerStream
}

type logManagerDownloadJobMgrLogFileServer struct {
	grpc.ServerStream
}

func (x *logManagerDownloadJobMgrLogFileServer) Send(m *FileContent) error {
	return x.ServerStream.SendMsg(m)
}

func _LogManager_DownloadTaskMgrLogFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadTaskMgrRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogManagerServer).DownloadTaskMgrLogFile(m, &logManagerDownloadTaskMgrLogFileServer{stream})
}

type LogManager_DownloadTaskMgrLogFileServer interface {
	Send(*FileContent) error
	grpc.ServerStream
}

type logManagerDownloadTaskMgrLogFileServer struct {
	grpc.ServerStream
}

func (x *logManagerDownloadTaskMgrLogFileServer) Send(m *FileContent) error {
	return x.ServerStream.SendMsg(m)
}

func _LogManager_UploadLogFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogManagerServer).UploadLogFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LogManager/UploadLogFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogManagerServer).UploadLogFile(ctx, req.(*UploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogManager_GetUploadingTaskStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogManagerServer).GetUploadingTaskStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LogManager/GetUploadingTaskStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogManagerServer).GetUploadingTaskStat(ctx, req.(*TaskStatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LogManager_ServiceDesc is the grpc.ServiceDesc for LogManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "LogManager",
	HandlerType: (*LogManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListJMHistoryLogFiles",
			Handler:    _LogManager_ListJMHistoryLogFiles_Handler,
		},
		{
			MethodName: "ListTMHistoryLogFiles",
			Handler:    _LogManager_ListTMHistoryLogFiles_Handler,
		},
		{
			MethodName: "UploadLogFile",
			Handler:    _LogManager_UploadLogFile_Handler,
		},
		{
			MethodName: "GetUploadingTaskStat",
			Handler:    _LogManager_GetUploadingTaskStat_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadJobMgrLogFile",
			Handler:       _LogManager_DownloadJobMgrLogFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DownloadTaskMgrLogFile",
			Handler:       _LogManager_DownloadTaskMgrLogFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/logmanager.proto",
}
