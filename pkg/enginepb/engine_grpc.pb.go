// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package enginepb

import (
	context "context"
	model "github.com/DataWorkbench/gproto/pkg/model"
	request "github.com/DataWorkbench/gproto/pkg/request"
	response "github.com/DataWorkbench/gproto/pkg/response"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// EngineClient is the client API for Engine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineClient interface {
	// DeleteWorkspaces for all resource of specified space ids.
	DeleteWorkspaces(ctx context.Context, in *request.DeleteWorkspaces, opts ...grpc.CallOption) (*model.EmptyStruct, error)
}

type engineClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineClient(cc grpc.ClientConnInterface) EngineClient {
	return &engineClient{cc}
}

func (c *engineClient) DeleteWorkspaces(ctx context.Context, in *request.DeleteWorkspaces, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Engine/DeleteWorkspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EngineServer is the server API for Engine service.
// All implementations must embed UnimplementedEngineServer
// for forward compatibility
type EngineServer interface {
	// DeleteWorkspaces for all resource of specified space ids.
	DeleteWorkspaces(context.Context, *request.DeleteWorkspaces) (*model.EmptyStruct, error)
	mustEmbedUnimplementedEngineServer()
}

// UnimplementedEngineServer must be embedded to have forward compatible implementations.
type UnimplementedEngineServer struct {
}

func (UnimplementedEngineServer) DeleteWorkspaces(context.Context, *request.DeleteWorkspaces) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkspaces not implemented")
}
func (UnimplementedEngineServer) mustEmbedUnimplementedEngineServer() {}

// UnsafeEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServer will
// result in compilation errors.
type UnsafeEngineServer interface {
	mustEmbedUnimplementedEngineServer()
}

func RegisterEngineServer(s grpc.ServiceRegistrar, srv EngineServer) {
	s.RegisterService(&_Engine_serviceDesc, srv)
}

func _Engine_DeleteWorkspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DeleteWorkspaces)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).DeleteWorkspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Engine/DeleteWorkspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).DeleteWorkspaces(ctx, req.(*request.DeleteWorkspaces))
	}
	return interceptor(ctx, in, info, handler)
}

var _Engine_serviceDesc = grpc.ServiceDesc{
	ServiceName: "enginepb.Engine",
	HandlerType: (*EngineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteWorkspaces",
			Handler:    _Engine_DeleteWorkspaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine.proto",
}

// FlinkClient is the client API for Flink service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlinkClient interface {
	ListAvailableFlinkVersions(ctx context.Context, in *model.EmptyStruct, opts ...grpc.CallOption) (*response.ListAvailableFlinkVersions, error)
	// Describe flink cluster api that job-manager commit job to
	DescribeFlickClusterAPI(ctx context.Context, in *request.DescribeFlickClusterAPI, opts ...grpc.CallOption) (*response.DescribeFlickClusterAPI, error)
	CreateFlinkCluster(ctx context.Context, in *request.CreateFlinkCluster, opts ...grpc.CallOption) (*response.CreateFlinkCluster, error)
	ListFlinkClusters(ctx context.Context, in *request.ListFlinkClusters, opts ...grpc.CallOption) (*response.ListFlinkClusters, error)
	DescribeFlinkCluster(ctx context.Context, in *request.DescribeFlinkCluster, opts ...grpc.CallOption) (*response.DescribeFlinkCluster, error)
	UpdateFlinkCluster(ctx context.Context, in *request.UpdateFlinkCluster, opts ...grpc.CallOption) (*model.EmptyStruct, error)
	DeleteFlinkClusters(ctx context.Context, in *request.DeleteFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error)
	StartFlinkClusters(ctx context.Context, in *request.StartFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error)
	StopFlinkClusters(ctx context.Context, in *request.StopFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error)
}

type flinkClient struct {
	cc grpc.ClientConnInterface
}

func NewFlinkClient(cc grpc.ClientConnInterface) FlinkClient {
	return &flinkClient{cc}
}

func (c *flinkClient) ListAvailableFlinkVersions(ctx context.Context, in *model.EmptyStruct, opts ...grpc.CallOption) (*response.ListAvailableFlinkVersions, error) {
	out := new(response.ListAvailableFlinkVersions)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/ListAvailableFlinkVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) DescribeFlickClusterAPI(ctx context.Context, in *request.DescribeFlickClusterAPI, opts ...grpc.CallOption) (*response.DescribeFlickClusterAPI, error) {
	out := new(response.DescribeFlickClusterAPI)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/DescribeFlickClusterAPI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) CreateFlinkCluster(ctx context.Context, in *request.CreateFlinkCluster, opts ...grpc.CallOption) (*response.CreateFlinkCluster, error) {
	out := new(response.CreateFlinkCluster)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/CreateFlinkCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) ListFlinkClusters(ctx context.Context, in *request.ListFlinkClusters, opts ...grpc.CallOption) (*response.ListFlinkClusters, error) {
	out := new(response.ListFlinkClusters)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/ListFlinkClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) DescribeFlinkCluster(ctx context.Context, in *request.DescribeFlinkCluster, opts ...grpc.CallOption) (*response.DescribeFlinkCluster, error) {
	out := new(response.DescribeFlinkCluster)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/DescribeFlinkCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) UpdateFlinkCluster(ctx context.Context, in *request.UpdateFlinkCluster, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/UpdateFlinkCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) DeleteFlinkClusters(ctx context.Context, in *request.DeleteFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/DeleteFlinkClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) StartFlinkClusters(ctx context.Context, in *request.StartFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/StartFlinkClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flinkClient) StopFlinkClusters(ctx context.Context, in *request.StopFlinkClusters, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Flink/StopFlinkClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlinkServer is the server API for Flink service.
// All implementations must embed UnimplementedFlinkServer
// for forward compatibility
type FlinkServer interface {
	ListAvailableFlinkVersions(context.Context, *model.EmptyStruct) (*response.ListAvailableFlinkVersions, error)
	// Describe flink cluster api that job-manager commit job to
	DescribeFlickClusterAPI(context.Context, *request.DescribeFlickClusterAPI) (*response.DescribeFlickClusterAPI, error)
	CreateFlinkCluster(context.Context, *request.CreateFlinkCluster) (*response.CreateFlinkCluster, error)
	ListFlinkClusters(context.Context, *request.ListFlinkClusters) (*response.ListFlinkClusters, error)
	DescribeFlinkCluster(context.Context, *request.DescribeFlinkCluster) (*response.DescribeFlinkCluster, error)
	UpdateFlinkCluster(context.Context, *request.UpdateFlinkCluster) (*model.EmptyStruct, error)
	DeleteFlinkClusters(context.Context, *request.DeleteFlinkClusters) (*model.EmptyStruct, error)
	StartFlinkClusters(context.Context, *request.StartFlinkClusters) (*model.EmptyStruct, error)
	StopFlinkClusters(context.Context, *request.StopFlinkClusters) (*model.EmptyStruct, error)
	mustEmbedUnimplementedFlinkServer()
}

// UnimplementedFlinkServer must be embedded to have forward compatible implementations.
type UnimplementedFlinkServer struct {
}

func (UnimplementedFlinkServer) ListAvailableFlinkVersions(context.Context, *model.EmptyStruct) (*response.ListAvailableFlinkVersions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableFlinkVersions not implemented")
}
func (UnimplementedFlinkServer) DescribeFlickClusterAPI(context.Context, *request.DescribeFlickClusterAPI) (*response.DescribeFlickClusterAPI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeFlickClusterAPI not implemented")
}
func (UnimplementedFlinkServer) CreateFlinkCluster(context.Context, *request.CreateFlinkCluster) (*response.CreateFlinkCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFlinkCluster not implemented")
}
func (UnimplementedFlinkServer) ListFlinkClusters(context.Context, *request.ListFlinkClusters) (*response.ListFlinkClusters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFlinkClusters not implemented")
}
func (UnimplementedFlinkServer) DescribeFlinkCluster(context.Context, *request.DescribeFlinkCluster) (*response.DescribeFlinkCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeFlinkCluster not implemented")
}
func (UnimplementedFlinkServer) UpdateFlinkCluster(context.Context, *request.UpdateFlinkCluster) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFlinkCluster not implemented")
}
func (UnimplementedFlinkServer) DeleteFlinkClusters(context.Context, *request.DeleteFlinkClusters) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFlinkClusters not implemented")
}
func (UnimplementedFlinkServer) StartFlinkClusters(context.Context, *request.StartFlinkClusters) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartFlinkClusters not implemented")
}
func (UnimplementedFlinkServer) StopFlinkClusters(context.Context, *request.StopFlinkClusters) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopFlinkClusters not implemented")
}
func (UnimplementedFlinkServer) mustEmbedUnimplementedFlinkServer() {}

// UnsafeFlinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlinkServer will
// result in compilation errors.
type UnsafeFlinkServer interface {
	mustEmbedUnimplementedFlinkServer()
}

func RegisterFlinkServer(s grpc.ServiceRegistrar, srv FlinkServer) {
	s.RegisterService(&_Flink_serviceDesc, srv)
}

func _Flink_ListAvailableFlinkVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(model.EmptyStruct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).ListAvailableFlinkVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/ListAvailableFlinkVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).ListAvailableFlinkVersions(ctx, req.(*model.EmptyStruct))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_DescribeFlickClusterAPI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DescribeFlickClusterAPI)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).DescribeFlickClusterAPI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/DescribeFlickClusterAPI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).DescribeFlickClusterAPI(ctx, req.(*request.DescribeFlickClusterAPI))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_CreateFlinkCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.CreateFlinkCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).CreateFlinkCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/CreateFlinkCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).CreateFlinkCluster(ctx, req.(*request.CreateFlinkCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_ListFlinkClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ListFlinkClusters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).ListFlinkClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/ListFlinkClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).ListFlinkClusters(ctx, req.(*request.ListFlinkClusters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_DescribeFlinkCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DescribeFlinkCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).DescribeFlinkCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/DescribeFlinkCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).DescribeFlinkCluster(ctx, req.(*request.DescribeFlinkCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_UpdateFlinkCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.UpdateFlinkCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).UpdateFlinkCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/UpdateFlinkCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).UpdateFlinkCluster(ctx, req.(*request.UpdateFlinkCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_DeleteFlinkClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DeleteFlinkClusters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).DeleteFlinkClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/DeleteFlinkClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).DeleteFlinkClusters(ctx, req.(*request.DeleteFlinkClusters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_StartFlinkClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.StartFlinkClusters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).StartFlinkClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/StartFlinkClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).StartFlinkClusters(ctx, req.(*request.StartFlinkClusters))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flink_StopFlinkClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.StopFlinkClusters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlinkServer).StopFlinkClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Flink/StopFlinkClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlinkServer).StopFlinkClusters(ctx, req.(*request.StopFlinkClusters))
	}
	return interceptor(ctx, in, info, handler)
}

var _Flink_serviceDesc = grpc.ServiceDesc{
	ServiceName: "enginepb.Flink",
	HandlerType: (*FlinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAvailableFlinkVersions",
			Handler:    _Flink_ListAvailableFlinkVersions_Handler,
		},
		{
			MethodName: "DescribeFlickClusterAPI",
			Handler:    _Flink_DescribeFlickClusterAPI_Handler,
		},
		{
			MethodName: "CreateFlinkCluster",
			Handler:    _Flink_CreateFlinkCluster_Handler,
		},
		{
			MethodName: "ListFlinkClusters",
			Handler:    _Flink_ListFlinkClusters_Handler,
		},
		{
			MethodName: "DescribeFlinkCluster",
			Handler:    _Flink_DescribeFlinkCluster_Handler,
		},
		{
			MethodName: "UpdateFlinkCluster",
			Handler:    _Flink_UpdateFlinkCluster_Handler,
		},
		{
			MethodName: "DeleteFlinkClusters",
			Handler:    _Flink_DeleteFlinkClusters_Handler,
		},
		{
			MethodName: "StartFlinkClusters",
			Handler:    _Flink_StartFlinkClusters_Handler,
		},
		{
			MethodName: "StopFlinkClusters",
			Handler:    _Flink_StopFlinkClusters_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine.proto",
}

// NetworkClient is the client API for Network service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkClient interface {
	CreateNetwork(ctx context.Context, in *request.CreateNetwork, opts ...grpc.CallOption) (*response.CreateNetwork, error)
	ListNetworks(ctx context.Context, in *request.ListNetworks, opts ...grpc.CallOption) (*response.ListNetworks, error)
	DescribeNetwork(ctx context.Context, in *request.DescribeNetwork, opts ...grpc.CallOption) (*response.DescribeNetwork, error)
	UpdateNetwork(ctx context.Context, in *request.UpdateNetwork, opts ...grpc.CallOption) (*model.EmptyStruct, error)
	DeleteNetworks(ctx context.Context, in *request.DeleteNetworks, opts ...grpc.CallOption) (*model.EmptyStruct, error)
}

type networkClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkClient(cc grpc.ClientConnInterface) NetworkClient {
	return &networkClient{cc}
}

func (c *networkClient) CreateNetwork(ctx context.Context, in *request.CreateNetwork, opts ...grpc.CallOption) (*response.CreateNetwork, error) {
	out := new(response.CreateNetwork)
	err := c.cc.Invoke(ctx, "/enginepb.Network/CreateNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkClient) ListNetworks(ctx context.Context, in *request.ListNetworks, opts ...grpc.CallOption) (*response.ListNetworks, error) {
	out := new(response.ListNetworks)
	err := c.cc.Invoke(ctx, "/enginepb.Network/ListNetworks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkClient) DescribeNetwork(ctx context.Context, in *request.DescribeNetwork, opts ...grpc.CallOption) (*response.DescribeNetwork, error) {
	out := new(response.DescribeNetwork)
	err := c.cc.Invoke(ctx, "/enginepb.Network/DescribeNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkClient) UpdateNetwork(ctx context.Context, in *request.UpdateNetwork, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Network/UpdateNetwork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkClient) DeleteNetworks(ctx context.Context, in *request.DeleteNetworks, opts ...grpc.CallOption) (*model.EmptyStruct, error) {
	out := new(model.EmptyStruct)
	err := c.cc.Invoke(ctx, "/enginepb.Network/DeleteNetworks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServer is the server API for Network service.
// All implementations must embed UnimplementedNetworkServer
// for forward compatibility
type NetworkServer interface {
	CreateNetwork(context.Context, *request.CreateNetwork) (*response.CreateNetwork, error)
	ListNetworks(context.Context, *request.ListNetworks) (*response.ListNetworks, error)
	DescribeNetwork(context.Context, *request.DescribeNetwork) (*response.DescribeNetwork, error)
	UpdateNetwork(context.Context, *request.UpdateNetwork) (*model.EmptyStruct, error)
	DeleteNetworks(context.Context, *request.DeleteNetworks) (*model.EmptyStruct, error)
	mustEmbedUnimplementedNetworkServer()
}

// UnimplementedNetworkServer must be embedded to have forward compatible implementations.
type UnimplementedNetworkServer struct {
}

func (UnimplementedNetworkServer) CreateNetwork(context.Context, *request.CreateNetwork) (*response.CreateNetwork, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedNetworkServer) ListNetworks(context.Context, *request.ListNetworks) (*response.ListNetworks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedNetworkServer) DescribeNetwork(context.Context, *request.DescribeNetwork) (*response.DescribeNetwork, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeNetwork not implemented")
}
func (UnimplementedNetworkServer) UpdateNetwork(context.Context, *request.UpdateNetwork) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNetwork not implemented")
}
func (UnimplementedNetworkServer) DeleteNetworks(context.Context, *request.DeleteNetworks) (*model.EmptyStruct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetworks not implemented")
}
func (UnimplementedNetworkServer) mustEmbedUnimplementedNetworkServer() {}

// UnsafeNetworkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServer will
// result in compilation errors.
type UnsafeNetworkServer interface {
	mustEmbedUnimplementedNetworkServer()
}

func RegisterNetworkServer(s grpc.ServiceRegistrar, srv NetworkServer) {
	s.RegisterService(&_Network_serviceDesc, srv)
}

func _Network_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.CreateNetwork)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Network/CreateNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServer).CreateNetwork(ctx, req.(*request.CreateNetwork))
	}
	return interceptor(ctx, in, info, handler)
}

func _Network_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.ListNetworks)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Network/ListNetworks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServer).ListNetworks(ctx, req.(*request.ListNetworks))
	}
	return interceptor(ctx, in, info, handler)
}

func _Network_DescribeNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DescribeNetwork)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServer).DescribeNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Network/DescribeNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServer).DescribeNetwork(ctx, req.(*request.DescribeNetwork))
	}
	return interceptor(ctx, in, info, handler)
}

func _Network_UpdateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.UpdateNetwork)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServer).UpdateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Network/UpdateNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServer).UpdateNetwork(ctx, req.(*request.UpdateNetwork))
	}
	return interceptor(ctx, in, info, handler)
}

func _Network_DeleteNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(request.DeleteNetworks)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServer).DeleteNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/enginepb.Network/DeleteNetworks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServer).DeleteNetworks(ctx, req.(*request.DeleteNetworks))
	}
	return interceptor(ctx, in, info, handler)
}

var _Network_serviceDesc = grpc.ServiceDesc{
	ServiceName: "enginepb.Network",
	HandlerType: (*NetworkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _Network_CreateNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _Network_ListNetworks_Handler,
		},
		{
			MethodName: "DescribeNetwork",
			Handler:    _Network_DescribeNetwork_Handler,
		},
		{
			MethodName: "UpdateNetwork",
			Handler:    _Network_UpdateNetwork_Handler,
		},
		{
			MethodName: "DeleteNetworks",
			Handler:    _Network_DeleteNetworks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine.proto",
}
